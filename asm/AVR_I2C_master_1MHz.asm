; Title: I2C master driver without use of USI hardware
; Version: 5.0

; from 100WOm_I2C_master.asm V4
; Added   : 1 MHz clock option
;           I2C_MASTER_STOP_OR_RESTART option

; from I2C_master_no_USI_tinyx61.asm V3
; suppr.  : all conditionnaly options except I2C_FAST_MODE option

; from I2C_master_no_USI_tinyx61.asm V2
; Added   : Conditionnaly I2C_Master_Stop_Restart_Select
; mofified: length of string to send or to be received (0to255)
;           rPARAM      = unchanged in/out(slave address)
;           rCOUNTI     = new data count down, remplace rPARAM
; suppr.  : conditionnaly I2C_Master_Read auto buffer

; from I2C_master_no_USI_tinyx61.asm V 1.1
; Added   : conditionnaly I2C_Master_Read auto buffer
;           conditionnaly I/O configuration

; Last updated: 2011-01-26

; Target: ATtiny 1 MHz

; Comments: 146 bytes (without options), to compare with USI_TWI_Master.c file (256 bytes)

; timing, SCL clock generation and any test number of data are under I2C_Master control.
; slave can always strech SCL_low, before any bit, comprizing after Start_Condition.

; address Ack/Nack is generated by the slave on SDA line (released by the master)
; Two groups of eight addresses (0000xxxy and 1111xxxy) are not allowed (reserved)
; after address or data is sent, the transmitter (Master or Slave) must release SDA line to allow (N)Ack by the receiver
; data Ack/Nack are generated by the receiver (master or slave) on SDA line
; a master receiver must signal the end of data to the slave transmitter by sending a Nack bit
; Stop or restart conditions generated by master must be do after a Nack bit.
; after (N)ack bit is received, the Slave must release SDA line to allow master to generate stop or restart conditions
;     __     _____ _____ _..._ _____ _____ _____ _____ _____ _..._ _____ _____ _NACK      _
; SDA   \___/_MSB_X_____X_..._X_LSB_X_R/W_x_ACK_x_MSB_X_____X_..._X_____X_LSB_X_ACK_X____/
;     _____     _     _           _     _     _     _     _           _     _     _     ___
; SCL      \___/1\___/2\___...___/7\___/8\___/9\___/1\___/2\___...___/7\___/8\___/9\___/
;       ^                                                                                ^
;       |Start Condition                                                                 |stoP Condition
;     __     _____ _____ _..._ _____ _____ _____ _____ _____ _..._ _____ _____ _NACK ____
; SDA   \___/_MSB_X_____X_..._X_LSB_X_R/W_x_ACK_x_MSB_X_____X_..._X_____X_LSB_X_ACK_X    \_
;     _____     _     _           _     _     _     _     _           _     _     _     ___
; SCL      \___/1\___/2\___...___/7\___/8\___/9\___/1\___/2\___...___/7\___/8\___/9\___/   
;       ^                                                                                ^
;       |Start Condition                                                                 |reStart Condition
;                                                                                       
; tHIGH : SCL high time 
; tLOW : SCL low time
; tBUF : SDA high time between Stop and Start conditions
; tHD:STA : Start_Condition SCL high time after SDA is low
; tSU:STO : Stop_Condition SCL high time before SDA rise    
; tSU:STA : Start_Condition SCL high time before SDA fall
; tHD:DAT : SDA data change time after SCL is low
; the SDA line must be strobe just after SCL is high
; the SDA data must be change just after SCL is low
; normal mode   (up to 100 kHz) :   tHIGH   =   tHD:STA =   tSU:STO =   4�s
;                                   tLOW    =   tSU:STA =   tBUF    =   4,7�s
;                                   tHD:DAT &lt;=  3,45 �s
;
; to avoid generation of noise, the state of the lines "SDA and SCL" should be changed 
; only when we have to change their state
;-------------------------------------------------------------------------------------------------------------------------------;

;START COPY TO CONF FILE

;---------------------------------------;
; MACROS                                ;
;---------------------------------------;
;.macro ldiramp                         ; load immediate RAM pointer in XH,XL or YH,YL or ZH,ZL
;.IFDEF LARGE_RAM_SIZE                  ; ex : ldiramp XH,XL, address_buffer_in_ram
;   ldi     @0, high(@2)                ;
;.ENDIF                                 ;
;   ldi     @1, low(@2)                 ;
;.endmacro                              ;
;---------------------------------------;

;---------------------------------------;
; SETTING                               ;
;---------------------------------------;
;.set LARGE_RAM_SIZE    = 1             ; if RAM &gt; 256 bytes
;---------------------------------------;
; I2C MASTER SETTING                    ; from I2C_master_100kHz_Clk1MHz.asm
;---------------------------------------;
;.set I2C_MASTER_RESTART = 1            ; enable I2C master reStart condition
;.set I2C_MASTER_FLAGS = 1              ; enable I2C master flags in GPIORx
;---------------------------------------;

;---------------------------------------;
; I2C MASTER I/O usage                  ; from I2C_master_100kHz_Clk1MHz.asm
;---------------------------------------;
;.equ I2C_MR_OUTPUT     = PORTX         ;
;.equ I2C_MR_DDR        = DDRX          ;
;.equ I2C_MR_INPUT      = PINX          ;
;.equ MR_SDA            = PINXy         ;
;.equ MR_SCL            = PINXz         ;
;---------------------------------------;

;---------------------------------------;
; I2C MASTER Registers usage            ; from I2C_master_100kHz_Clk1MHz.asm
;---------------------------------------;
;.def rPARAM            = r..   ;(16-25);
;.def rCOUNTI           = r..   ;(16-25);
;.def rCOUNTJ           = r..   ;(16-25);
;---------------------------------------;

;---------------------------------------;
; I2C MASTER declarations               ; from I2C_master_100kHz_Clk1MHz.asm
;---------------------------------------;
.IFDEF I2C_MASTER_FLAGS                 ;
;.equ GPFLAGS           = GPIORx        ;
;.equ I2C_SLAVE_ADR_ACK = x             ;
.ENDIF                                  ;
;.equ I2C_NACK_BIT      = 0             ; Bit position for Ack/Nack bit.
;.equ I2C_RW_BIT        = 0             ; R/W bit position
;.equ I2C_RESTART_FLAG  = 0             ; reStart flag position in Slave_Address
;---------------------------------------;

;---------------------------------------;
; I2C MASTER RAM usage                  ; from I2C_master_100kHz_Clk1MHz.asm
;---------------------------------------;
;I2C_Mr_RX_Buf_Adr:                     ; buffer for I2C_Master Reading
;.db 0, 0, 0, 0, 0, 0, 0, 0             ; 8 bytes lentgh
;I2C_Mr_TX_Buf_Adr:                     ; buffer for I2C_Master Writing
;.db 0, 0, 0, 0, 0, 0, 0, 0             ; 8 bytes lentgh
;---------------------------------------;

;---------------------------------------;
; I2C MASTER EEPROM usage               ; from I2C_master_100kHz_Clk1MHz.asm
;---------------------------------------;

;---------------------------------------;
; I2C MASTER interrupts handlers        ; from I2C_master_100kHz_Clk1MHz.asm
;---------------------------------------;

;STOP COPY TO CONF FILE

;START COPY TO THE INIT FILE

;---------------------------------------;
;I2C_Master_Init:                       ; init I/O as I2C SDA &amp; SCL lines, in idle state ; 4 words
;---------------------------------------; but not necessary after reset !
;   cbi     I2C_MR_DDR, MR_SDA          ; 1-set SDA as input, in released state by external pull up resistor.
;   cbi     I2C_MR_OUTPUT, MR_SDA       ; preset SDA mode output low (but SDA is always high).
;   cbi     I2C_MR_DDR, MR_SCL          ; 2-set SCL as input, in released state by external pull up resistor.
;   cbi     I2C_MR_OUTPUT, MR_SCL       ; preset SCL mode output low (but SCL is always high).
;---------------------------------------;

;STOP COPY TO THE INIT FILE

;---------------------------------------;
I2C_Master:                             ; 73 words without options
;---------------------------------------;
                                        ; in  : YH:YL       = buffer_datas pointer
                                        ;       rCOUNTJ     = count_of_datas to be send or received (0to255)
                                        ;       rPARAM      = Slave_Address
                                        ;       rPARAM(0)   = reStart flag request
                                        ;       SREG bit T  = R/w flag (i.e. master_Read or master_write)
                                        ; used: rCOUNTI     = number of bits to be transmitted
                                        ; out : rCOUNTJ     = unchanged
                                        ;       rPARAM      = 0 if I2C_Slave_Nack_On_Address
                                        ;                     otherwise unchanged 
                                        ;       SREG bit T  = unchanged
                                        ;       rCOUNTI     = data count down
                                        ;                   = 0 &lt;==&gt; transfert ok
                                        ;                   = rCOUNTJ + 1 ==&gt; Nack on address
;---------------------------------------;
I2C_Master_Start_Cond:                  ; do Start_Condition
;---------------------------------------;
    sbi     I2C_MR_DDR, MR_SDA          ; 4-force SDA output low
    rjmp    I2C_Master_Start_Cond1      ; 5-wait Start_Condition SCL high time after SDA is low, 4 cycles
I2C_Master_Start_Cond1:                 ;
    rjmp    I2C_Master_Start_Cond2      ;
I2C_Master_Start_Cond2:                 ;
    sbi     I2C_MR_DDR, MR_SCL          ; 6-force SCL output low
;---------------------------------------;
I2C_Master_Write_Address:               ;
;---------------------------------------;
.IFDEF I2C_MASTER_FLAGS                 ;
    sbi     GPFLAGS, I2C_SL_ADR_ACK     ; set as good address return
.ENDIF                                  ;
    push    rPARAM                      ; save Slave_address with reSart flag
    push    rCOUNTJ                     ; save count of datas
    bld     rPARAM, I2C_RW_BIT          ; load read/write bit from SREG T bit into slave_address(0)
    inc     rCOUNTJ                     ; inc count_of_datas to add slave_address byte ; rCOUNTJ now is the bytes_count_down
;---------------------------------------;
I2C_Master_Write_Data:                  ; here, SDA is indetermined, SCL is maintained low by master
;---------------------------------------;
    ldi     rCOUNTI, 8                  ; prepare 8 bit Master writing
    rcall   I2C_Master_Write            ; rPARAM = data, rCOUNTI = count bits transfert
    ldi     rCOUNTI, 1                  ; prepare to receive (N)Ack bit
    rcall   I2C_Master_Read             ; rCOUNTI = count bits transfert
    sbrs    rPARAM, I2C_NACK_BIT        ; test Nack bit (=1)
    rjmp    I2C_Master_Check_Count_Down ; when  Ack bit (=0)
    rjmp    I2C_Master_End_Of_Transmit  ; on Nack bit sent by I2C_Slave
;---------------------------------------;
I2C_Master_Read_Data:                   ; here, SDA is indetermined, SCL is maintained low by master
;---------------------------------------;
    ldi     rCOUNTI, 8                  ; prepare 8 bit Master reading
    rcall   I2C_Master_Read             ; rCOUNTI = count bits transfert
    st      Y+, rPARAM                  ; store received byte
    ser     rPARAM                      ; prepare rPARAM(7) = 1 = Nack bit
    ldi     rCOUNTI, 1                  ; prepare to send one bit 
    cpse    rCOUNTJ, rCOUNTI            ; here, the end of bytes_count_down value in rCOUNTJ = 1 
    sub     rPARAM, rPARAM              ; rPARAM(7) = 0 = Ack bit
    out     USIDR, rPARAM               ;
    rcall   I2C_Master_Write            ; rPARAM = data, rCOUNTI = count bits transfert
;---------------------------------------;
I2C_Master_Check_Count_Down:            ;
;---------------------------------------;
    dec     rCOUNTJ                     ; here, end of bytes_count_down is 0
    breq    I2C_Master_End_Of_Transmit  ;
    brts    I2C_Master_Read_Data        ; if SREG bit T = 1
    ld      rPARAM, Y+                  ; else load data to write by I2C_master
    rjmp    I2C_Master_Write_Data       ; 
;---------------------------------------;
I2C_Master_End_Of_Transmit:             ; I2C_Master End Of Transfert, in all case
;---------------------------------------;
    mov     rCOUNTI, rCOUNTJ            ; rCOUNTI = bytes_count_down
    pop     rCOUNTJ                     ; rCOUNTJ = count_of_datas
    pop     rPARAM                      ; rPARAM  = Slave_address
    cp      RCOUNTJ, rCOUNTI            ; count_of_datas &gt;= bytes_count_down &lt;==&gt; I2C_Slave_Ack_On_Address  
    brsh    I2C_Master_Stop_Or_reStart  ;
;---------------------------------------;
I2C_Master_Nack_On_Address:             ;
;---------------------------------------;
    clr     rPARAM                      ; avoid reStart subsequently
.IFDEF I2C_MASTER_FLAGS                 ;
    cbi     GPFLAGS, I2C_SL_ADR_ACK     ;
.ENDIF                                  ;
;---------------------------------------;
I2C_Master_Stop_Or_reStart:             ; here, SDA is indetermined, SCL is maintained low by master 
;---------------------------------------;
.IFDEF I2C_MASTER_RESTART               ;
    sbrs    rPARAM, I2C_RESTART_FLAG    ;
    rjmp    I2C_Master_Stop_Cond        ;
;---------------------------------------;
I2C_Master_reStart_Cond:                ; prepare Start_Condition
;---------------------------------------;
    cbi     I2C_MR_DDR, MR_SDA          ; 1-release SDA
    cbi     I2C_MR_DDR, MR_SCL          ; 2-release SCL
    ret                                 ; wait Start_Condition SCL high time before SDA fall 5 cycles
.ENDIF                                  ;
;---------------------------------------;
I2C_Master_Stop_Cond:                   ;
;---------------------------------------;
    sbi     I2C_MR_DDR, MR_SDA          ; force SDA output low
    rjmp    I2C_Master_Stop_Cond1       ; wait SCL low time
I2C_Master_Stop_Cond1:                  ; 5 cycles -1
    rjmp    I2C_Master_Stop_Cond2       ;
I2C_Master_Stop_Cond2:                  ;
    cbi     I2C_MR_DDR, MR_SCL          ; release SCL (HIGH)
I2C_Master_sP_Wait_SCL_High:            ;
    sbis    I2C_MR_INPUT, MR_SCL        ;
    rjmp    I2C_Master_sP_wait_SCL_High ; wait for SCL released by slave(s)
    rjmp    I2C_Master_Stop_Cond3       ; wait Stop_Condition SCL high time before SDA rise
I2C_Master_Stop_Cond3:                  ; 4 cycles
    cbi     I2C_MR_DDR, MR_SDA          ; release SDA (HIGH)
    ret                                 ; wait SDA high time between Stop and Start conditions 5 cycles
;---------------------------------------;

;---------------------------------------;
I2C_Master_Write:                       ; here, SDA is indetermined, SCL is maintained low by master
;---------------------------------------;
    sbrs    rPARAM, 7                   ; skip if rPARAM(7) is high
    sbi     I2C_MR_DDR, MR_SDA          ; else force SDA low
    sbrc    rPARAM, 7                   ; skip if rPARAM(7) is low
    cbi     I2C_MR_DDR, MR_SDA          ; else release SDA (high)
    lsl     rPARAM                      ; then shift left rPARAM for next step
    rjmp    I2C_Master_Write1           ; wait for SCL low time 5 cycles - 1 (lsl)
I2C_Master_Write1:                      ;
    rjmp    I2C_Master_Write2           ;
I2C_Master_Write2:                      ;
    cbi     I2C_MR_DDR, MR_SCL          ; release SCL (HIGH)
I2C_Master_Wr_Wait_SCL_High:            ;
    sbis    I2C_MR_INPUT, MR_SCL        ;
    rjmp    I2C_Master_Wr_wait_SCL_High ; wait until SCL is released by Slave(s)
    rjmp    I2C_Master_Write3           ; wait SCL high time 4 cycles
I2C_Master_Write3:                      ;
    sbi     I2C_MR_DDR, MR_SCL          ; force SCL low
    dec     rCOUNTI                     ; decrement bits count down
    brne    I2C_Master_Write            ;
    ret                                 ; here, SCL is maintained low by master and SDA is indetermined
;---------------------------------------;

;---------------------------------------;
I2C_Master_Read:                        ; here, SDA is indetermined, SCL is maintained low by master
;---------------------------------------;
    cbi     I2C_MR_DDR, MR_SDA          ; release SDA (high), SDA in input
    rjmp    I2C_Master_Read1            ; wait for SCL low time 5 cycles
I2C_Master_Read1:                       ;
    rjmp    I2C_Master_Read2            ;
I2C_Master_Read2:                       ;
    cbi     I2C_MR_DDR, MR_SCL          ; release SCL (HIGH)
I2C_Master_Rd_Wait_SCL_High:            ;
    sbis    I2C_MR_INPUT, MR_SCL        ;
    rjmp    I2C_Master_Rd_wait_SCL_High ; wait until SCL is released by slave(s)
    nop                                 ; wait SCL high time 4 cycles - 1 (lsl)
    lsl     rPARAM                      ; rPARAM(0) &lt;-- 0
    sbic    I2C_MR_INPUT, MR_SDA        ; skip if SDA is low
    ori     rPARAM, 0x01                ; else rPARAM(0) = 1 
    sbi     I2C_MR_DDR, MR_SCL          ; force SCL low
    dec     rCOUNTI                     ; bits count down
    brne    I2C_Master_Read             ;
    ret                                 ; here, SCL is maintained low by master and SDA is indetermined
;---------------------------------------;